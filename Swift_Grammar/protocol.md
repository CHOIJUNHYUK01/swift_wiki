# 프로토콜

> 클래스의 단점을 보완해 만든 것

### 클래스 단점이 뭔데

1. 하나의 클래스만 상속이 가능하다.
2. 기본적인 상위 클래스의 메모리 구조를 따라갈 수밖에 없다.
3. 클래스끼리만 상속이 가능하다.

### 프로토콜이 보완한 것

1. 다중 상속이 가능하다.
2. 필수 요구사항만 구현하면 사용이 가능하다.
3. 클래스든, 열거형이든, 구조체든 모두 상속받을 수 있다.

### 요구사항 정의 방법

1. 속성 요구사항

저장 속성 / 계산 속성으로 모두 구현이 가능하다.
프로토콜 요구사항만으로는 저장/계산 속성 구별이 불가능하다.

타입 속성으로 static / class 키워드 모두 구현 가능하다.

```swift
protocol Dog {
    var name: String { get }
    var weight: Double { get, set }

    static var species: String { get }
}
```

2. 메서드 요구사항

메서드 헤드부분(인풋/아웃풋)을 정의한다.
mutating 키워드를 넣어야 구조체에서도 채택이 가능해진다. (구조체로 한정짓는 게 아님)

타입 메서드 또한 static / class 키워드 모두 구현 가능하다.

```swift
protocol Dog {
    func getName() -> String
    mutating func changeWeight()

    static func getSpecies()
}
```

3. 생성자 요구사항

요구사항으로 지정이 가능하다.
이를 사용하면, required 키워드를 붙여야 한다.
다만, final class 일 경우에는 required 키워드 생략이 가능하다.
반드시 지정생성자로 구현하지 않아도 된다. (편의 생성자로도 가능)

4. 서브스크립트 요구사항

최소한의 요구사항을 지정하면 된다. (get/set)

### extension을 이용한다면?

해당 프로토콜을 채택한 타입에서 실제 메서드 구현을 반복하지 않아도 된다.
단순히 기본 구현을 제공하는 개념이다.

메서드 한정해서 요구 사항이 아닌 추가 사항을 구현할 수 있다.

### 프로토콜은 타입이다.

> Swift에서는 프로토콜을 "일급객체"로 취급한다.

    1) "프로토콜"을 변수에 할당이 가능하다.
    2) 함수를 호출할 때, "프로토콜"을 파라미터로 전달할 수 있다.
    3) 함수에서 "프로토콜"을 반환할 수 있다.

### is 연산자 / as 연산자

프로토콜도 타입 캐스팅을 통해 구체적인 타입으로 사용이 가능하다.

### 상속이 된다면 요구 사항을 어떻게 해야 하는가

A를 상속받은 B 프로토콜을 채택했다면, A와 B의 요구사항을 모두 구현해야 한다.

### AnyObject 활용

해당 프로토콜이 AnyObject를 채택한다면, 클래스에서만 사용이 가능한 프로토콜이 된다.

### 선택적 요구사항 구현

@objc 어트리뷰트를 붙여 프로토콜을 만들면, 속성이나 메서드를 선택적 요구사항으로 만들 수 있다.

```swift
@objc protocol MyProtocol {
    @objc optional var isOn: Bool { get set}
    @objc optional func doSomething()
}
```
