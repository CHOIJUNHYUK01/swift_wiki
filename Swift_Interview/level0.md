# Level 0.

## 컴퓨터 구조와 관련하여 CPU, RAM, 저장장치의 역할과 상호 작용에 대해 설명해주세요.

CPU는 컴퓨터의 두뇌다. 모든 계산과 제어를 담당한다.
프로그램이 실행되면 CPU는 명령어를 해독하고 실행하는 역할을 한다. 이는 산술 연산, 논리 연산, 데이터 이동 등을 포함한다.
CPU는 레지스터라는 소규모의 메모리를 갖고 있어서, 연산에 필요한 데이터를 빠르게 읽고 쓸 수 있다.
CPU는 외부와의 통신을 담당하는 버스를 통해, RAM과 저장장치와 소통한다.

RAM은 주기억장치로서 현재 실행 중인 프로그램과 데이터를 일시적으로 저정한다.
CPU가 작업을 처리할 때, RAM은 해당 작업에 필요한 데이터와 명령어를 저장하고 필요할 때마다 읽어온다.
RAM은 빠른 읽기 및 쓰기 속도를 제공하며, 전원이 꺼지면 저장된 데이터가 지워진다.

저장 장치는 데이터를 장기적으로 보존하고 필요할 때, 접근할 수 있도록 한다.
하드 디스크 드라이브(HDD), 고체 상태 드라이브(SSD), 광 디스크 등이 이에 해당된다.
이는 CPU나 RAM보다 느리지만, 대용량의 데이터를 저장할 수 있다.
프로그램과 데이터는 저장장치에서 RAM으로 로드되어 CPU에 의해 실행된다.

1. 프로그램이 실행되면, 해당 프로그램의 명령어와 데이터는 저장장치에서 RAM으로 로드된다.
2. CPU는 RAM에 저장된 명령어를 읽어와 실행하고, 필요한 데이터를 RAM에서 읽어와 작업을 수행한다.
3. 작업 중인 데이터는 필요에 따라 RAM에 저장되거나 저장 장치로 다시 기록된다.
4. 프로그램이 종료되면, RAM에 저장된 데이터는 지워지지만, 저장 장치에 저장된 데이터는 유지된다.

### 캐시 메모리의 개념과 종류, 역할에 대해 설명해주세요.

CPU의 처리 속도와 주 기억 장치의 접근 속도 차이를 줄이기 위해 사용한다.
데이터 지역성을 활용해 메인 메모리에 있는 데이터를 캐시 메모리에 불러오고, 프로세서가 필요한 데이터를 캐시 메모리에서 먼저 찾도록 하면 시스템 성능을 향상시킬 수 있다.

L1, L2, L3 캐시 메모리가 있다.
이 순서대로 속도가 빠르고, 참조에 먼저 사용된다.
L1은 CPU 내부에 존재, L2는 CPU와 RAM 사이에 존재, L3는 메인보드에 존재한다.

### CPU 아키텍처의 종류(예: ARM, x86)와 특징에 대해 설명해주세요.

`x86`

- Intel 기반 32bit CPU다.
- 현존하는 PC 프로그램 대부분이 이 아키텍처를 지원한다.
- Windows, Linux, Mac OS(Big Sur까지)

`x86_64(amd64)`

- amd64라고도 한다.
- Intel 기반 64bit CPU고, x86과 호환된다.
- 사실상 AMD가 만드었는데, Intel과 크로스 라이센싱하여 둘 다 쓴다.
- Windows, Linux, Mac OS(Big Sur까지)

`arm`

- arm기반 32bit CPU다.
- x86과 아예 달라서 둘이 호환이 안 된다.
- Linux, Mac OS (Monterey부터), Android, iOS, 기타 모든 작은 기기에서 성능을 내야하는 경우에 사용한다. (공유기도 해당)

`arm64(arm64/v8)`

- arm기반 64bit CPU다.
- 32bit arm과 호환된다.
- Linux, Mac OS (Monterey부터), Android, iOS, 기타 모든 작은 기기에서 성능을 내야하는 경우에 사용한다. (공유기도 해당)

`32bit와 64bit 차이`

이는 CPU가 데이터를 처리하는 최소 단위다.
CPU가 I/O 버스를 통해 데이터 내외부로 데이터를 전송하는데, 이때 전송하는 데이터 단위(레지스터의 1회 처리값)가 32비트인가 64비트인가의 차이다.

32비트는 x86을, 64비트는 x64를 의미한다.
하지만, `x86_64`는 역 호환성을 갖고 있어, 64비트 아키텍쳐임에도 불구하고 32비트 아키텍쳐로 된 프로그램과 호환이 된다.

ARM은 단순한 아키텍처고, 가격이 저렴하고 저전력을 갖춰 소형기기에 많이 사용했다.
스마트폰 시대가 되면서, 모바일 용으로 많이 쓰이게 됐다.
그러고 엄청난 발전을 거듭하면서 속도 면에서 이제 PC에 근접한 수준에 이르게 됐다.

Apple이 자체 개발한 애플 실리콘 노트북이 ARM 호환 CPU다.

### iOS 기기에서 사용되는 AP(Application Processor)의 특징과 역할에 대해 설명해주세요.

AP는 스마트폰의 CPU다.
하지만 PC의 CPU와는 다르게 CPU, 메모리, GPU 등 기능을 다 갖고 있는 게 AP다.
그래서 AP를 SoC(System on Chip)이라고 부르는 이유다. 모든 기능이 하나의 칩에 들어가 있기 때문이다.
이 성능이 곧 스마트폰의 성능이 된다.

---

## 운영체제의 역할과 iOS에서의 운영체제 구조에 대해 설명해주세요.

운영체제(Operating System, OS)는 컴퓨터 시스템의 핵심적인 소프트웨어다.
하드웨어 자원을 관리하고, 응용 프로그램이 원활하게 실행되도록 지원한다.

iOS는 애플이 개발한 모바일 운영체제로 iPhone, iPad, iPod 등의 장치에서 사용된다.
iOS의 운영체제 구조는 네 가지 주요 구성 요소가 있다.

1. 커널 (Kernel)

- iOS의 핵심 부분이며, 하드웨어와 상호작용을 한다.
- 프로세스 관리, 메모리 관리, 파일 시스템 관리 등 기본적인 운영체제 기능을 제공한다.
- 안정성과 보안을 유지하기 위해 권한 관리와 같은 기능도 수행한다.

2. 시스템 프레임워크

- iOS에서 제공되는 고수준의 API 및 라이브러리 집합이다.
- 주요 서비스 및 기능을 구현하고, 응용 프로그램과의 상호작용을 용이하게 한다.
- 예를 들어, UI 관리, 네트워킹, 데이터베이스 액세스, 그래픽 처리 등이 포함된다.

3. 유틸리티 프로그램

- iOS 시스템에는 다양한 유틸리티 프로그램이 포함되어 있다.
- 이들은 시스템 관리, 설정 구성, 디버깅 등의 작업을 수행하는데 사용된다.
- 예를 들어, 설정 앱, 시스템 모니터링 도구, 디버깅 도구 등이 있다.

4. 응용 프로그램

- iOS에서는 사용자가 직접 상호작용하는 응용 프로그램이 있다.
- 이러한 응용 프로그램은 iOS SDK를 사용해 개발되며, App Store에서 다운로드할 수 있다.
- 메세지, 사진, 웹 브라우징, 게임 등 다양한 용도의 응용 프로그램이 있다.

iOS 운영체제 구조는 안정성, 보안성, 성능, 사용자 경험 등을 고려해 설계되어있다.
이를 통해 iOS는 안정적이고 효율적으로 동작하며 다양한 응용 프로그램을 실행할 수 있다.

### 프로세스와 스레드의 차이점, iOS에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.

**일단 프로세스란?**

- 운영체제에 의해 실행되는 프로그램의 인스턴스다.
- 각 프로세스는 독립적인 메모리 공간을 할당받으며, 서로 영향을 끼치지 않는다.
- 각 프로세스는 최소한 하나의 스레드를 갖는다.
- 프로세스는 자신만의 주소 공간, 파일 및 디바이스, 시스템 자원 등을 갖는다.
- 프로세스 간 통신이 필요한 경우에는 IPC(Inter-Process Communication) 매커니즘이 사용된다.

**그럼 스레드란?**

- 스레드는 프로세스 내에서 실행되는 실행 단위로, 프로세스 자원을 공유한다.
- 하나의 프로세스에는 여러 스레드가 있을 수 있다.
- 스레드는 프로세스의 주소 공간을 공유하기에 스레드 간 데이터 공유가 쉽고 빠르다.
- 스레드는 프로세스 내에서 스케줄링되어 병렬적으로 실행될 수 있다.
- 스레드 간 통신이 필요한 경우에는 메모리 공간을 공유해 직접 데이터를 주고받을 수 있다.

즉, 프로세스는 프로그램의 실행 단위이자 독립적인 메모리 공간을 갖고 있다.
스레드는 프로세스 내에서 실행되는 실행 단위고 프로세스의 자원을 공유한다.
프로세스는 스레드의 컨텍스트 스위칭보다 오버헤드가 크지만, 스레드는 자원 공유를 통해 보다 효율적으로 동작할 수 있다.

**iOS에서는 어떻게 관리하나?**

iOS에서 프로세스와 스레드 관리는 안정성과 효율성을 최대화하기 위해 정교하게 이뤄진다.
iOS는 멀티태스킹 환경을 지원하며, 여러 응용 프로그램이 동시에 실행될 수 있다.

1. 프로세스 관리

- iOS에서는 각 앱이 별도의 프로세스로 실행된다. 이는 각 앱이 독립적인 메모리 공간을 갖고 있고, 다른 앱에 영향을 미치지 않도록 보장한다.
- iOS는 앱이 백그라운드에서 실행될 때, 시스템 리소스 사용을 최소화하고 배터리 수명을 최대화하기 위해 프로세스의 활성화를 조절한다. 이를 통해 백그라운드에서 실행 중인 앱이 시스템 성능에 부담을 주지 않도록 한다.

2. 스레드 관리

- iOS에서는 각 프로세스 내에서 여러 스레드가 실행된다. 주로 메인 스레드와 백그라운드 스레드로 구성된다.
- 메인 스레드는 UI 이벤트 처리 및 UI 업데이트와 같은 주요 작업을 담당한다. UI 업데이트는 반드시 메인 스레드에서 이뤄져야 한다.
- 백그라운드 스레드는 주로 네트워크 요청, 데이터 다운로드, 계산 등의 비동기 작업을 처리한다. 이를 통해 메인 스레드가 차단되거나 지연되지 않도록 한다.
- iOS에서는 Grand Centeral Dispatch(GCD)와 Operation Queue와 같은 API를 통해 스레드 관리를 용이하게 한다. 이를 통해 스레드의 생성, 관리, 작업 배정 등을 간편하게 처리할 수 있다.

3. 스레드 동기화 및 상호작용

- iOS에서는 다중 스레드 환경에서의 데이터 공유와 동기화를 위해 락(lock), 세마포어(semaphore), 조건 변수(condition variable) 등의 동기화 매커니즘을 제공한다.
- iOS에서는 메인 스레드와 백그라운드 스레드 간의 효율적인 통신을 위한 매커니즘을 제공한다. 예를 들어, 메인 스레드에서 백그라운드 스레드로 작업을 보내고, 작업이 완료되면 결과를 받아오는 등의 방법을 제공한다.

이와 같은 프로세스 및 스레드 관리 방법을 통해 iOS는 안정적이고 효율적인 멀티태스킹 환경을 제공해 다양한 앱이 원활하게 동작할 수 있도록 한다.

### 메모리 관리 기법 중 iOS에서 사용되는 방식과 그 특징에 대해 설명해주세요.

주요한 방식은 Automatic Reference Counting(ARC)다.
ARC는 Objective-C와 Swift 프로그래밍 언어에서 사용되며, 개발자가 메모리 관리를 자동으로 처리할 수 있도록 도와준다.

**특징**

1. 자동 메모리 관리

- ARC는 개발자가 객체의 수명을 관리하는데 필요한 코드를 직접 작성하지 않고도 메모리 관리를 자동으로 처리한다.
- 개발자는 객체를 생성할 때마다 ARC가 해당 객체에 대한 참조 카운트를 증가시키고, 해당 객체를 더 이상 사용하지 않을 때 ARC가 참조 카운트를 감소시킨다.
- 참조 카운트가 0이 되면, 해당 객체는 자동으로 해제된다.

2. 코드 간결성

- ARC를 사용하면 개발자가 메모리 관리에 대한 복잡한 코드를 작성할 필요가 없어진다. 이는 코드를 간결하게 유지하고 오류 발생 가능성을 줄여준다.

3. 실행 시간 오버헤드 없음

- ARC는 컴파일 시간에 메모리 관리 코드를 삽입하므로 실행 시간 오버헤드가 없다. 이는 성능에 부담을 주지 않으면서도 안정성을 유지한다.

4. Weak 참조와 순환 참조 해결

- ARC는 weak 참조를 사용해 객체 사이의 순환 참조를 방지한다. 순환 참조가 발생하면 메모리 누수가 발생할 수 있다.
- weak 참조를 통해 한 객체가 다른 객체를 강한 참조하는 동시에, 다른 객체는 약한 참조로 참조하므로 순환 참조를 방지할 수 있다.

5. 메모리 경고 및 오류 확인

- ARC를 사용하면 컴파일러가 메모리 관련 경고를 표시해, 개발자가 메모리 관리 오류를 미리 감지하고 수정할 수 있도록 도와준다.

ARC는 iOS 앱 개발에서 메모리 관리를 단순하고 효율적으로 처리하는 데 도움이 되는 강력한 도구다.
개발자는 ARC를 통해 안전하고 안정적인 앱을 개발할 수 있고, 메모리 관리에 대한 걱정을 덜어준다.

### iOS의 샌드박스(Sandbox) 개념과 역할, 앱 간 데이터 공유 방법에 대해 설명해주세요.

샌드박스는 각 앱이 자신의 독립적인 환경을 갖고 다른 앱 및 시스템 리소스와 격리되어 실행되는 보안 매커니즘이다.
이는 사용자의 개인 정보와 시스템의 안정성을 보호하기 위한 것이다.

1. 샌드박스의 역할

- 개별 앱은 자신만의 디렉토리와 파일 시스템 공간을 가지며, 이를 통해 다른 앱과 분리된다.
- 앱은 자신의 샌드박스 내에서만 실행되며, 다른 앱의 데이터나 시스템 리소스에 직접적인 접근을 할 수 없다.
- 샌드박스는 앱의 실행 환경을 격리해 사용자 데이터의 안정성과 개인 정보 보호를 유지한다.
- 앱이 App Store에서 배포되기 전에 샌드박스 내에서 실행되는 모든 작업은 애플의 기준에 따라 검토되어 보안을 확보한다.

2. 앱 간 데이터 공유 방법

- 다른 앱 간에 직접적인 데이터 공유가 제한된다. 하지만 몇 가지 매커니즘을 통해 앱 간 데이터를 공유할 수 있다.

**앱 그룹(App Groups)**

- 앱 그룹은 여러 앱이 공유할 수 있는 컨테이너를 생성한다.
- 이 컨테이너 내에서 데이터를 저장하고 공유할 수 있다. 주로 사용자 환경 설정, 공유 데이터베이스 또는 기타 설정 정보를 공유할 때 사용된다.

**응용 프로그램 확장(Extensions)**

- 응용 프로그램 확장을 통해 다른 앱과 데이터를 공유할 수 있다. 예를 들어, 공유 확장은 사용자가 다른 앱의 콘텐츠를 현재 앱에서 공유할 수 있도록 지원한다.

**URL Scheme**

- 앱은 URL Scheme을 사용해 다른 앱과 통신할 수 있다. 이를 통해 다른 앱을 열고 데이터를 전송할 수 있다.

**키체인(Keychain)**

- 키체인은 사용자의 인증 정보 및 기타 민감한 데이터를 보호하기 위한 iOS 시스템의 암호화된 저장소다. 키체인은 여러 앱이 공유할 수 있다.

iOS의 샌드박스 개념과 데이터 공유 방법은 사용자의 개인 정보 보호와 시스템의 안정성을 유지하는데 중요한 역할은 한다.
이를 통해 iOS 앱은 보안적으로 격리되고 사용자의 개인 정보를 안전하게 보호할 수 있다.

---

## iOS에서의 메모리 구조와 관리 방식에 대해 자세히 설명해주세요.

안정성과 성능을 극대화하기 위해 정교하게 설계되어 있다.

1. 메모리 구조

**스택(Stack)**

- 스택은 지역 변수와 함수 호출 정보를 저장하는 데 사용된다.
- 각 함수 호출은 스택에 새로운 프레임이 푸시되고, 함수가 반환될 때 해당 프레임이 팝 된다.
- 스택은 후입선출(LIFO, Last-In-First-Out)구조를 가지며, 크기가 제한되어 있다.

**힙(Heap)**

- 힙은 동적으로 할당된 메모리를 저장하는 데 사용된다.
- 앱이 런타임 중에 메모리를 요청할 때, 힙에서 할당된다.
- 힙은 메모리 할당과 해제를 위한 매우 유연한 구조를 갖고 있다.

**전역(Global) 및 정적(Static) 메모리 영역**

- 전역 및 정적 변수는 프로그램의 시작 지점에 할당되며, 프로그램이 종료될 때까지 유지된다.
- 전역 변수는 프로그램 어느 곳에서나 접근이 가능하다.

2. 메모리 관리 방식

**ARC**

- ARC는 Objective-C와 Swift에서 사용되는 자동 메모리 관리 기술이다.
- 개발자가 수동으로 메모리를 할당하고 해제할 필요가 없고, 객체의 참조 카운트를 자동으로 관리한다.
- 각 객체에 대한 참조 카운트가 0이 되면, 해당 객체가 자동으로 해제된다.

**메모리 경고 및 분석 도구**

- Xcode 및 Instruments와 같은 도구는 메모리 누수와 메모리 사용량을 분석하고 모니터링하는 데 사용된다.
- 개발자는 이러한 도구를 사용해 앱의 메모리 사용을 최적화하고 성능을 향상시킬 수 있다.

**최적화 및 최적화 방법**

- iOS에서는 메모리 사용을 최적화하기 위한 다양한 기술과 최적화 방법을 제공한다.
- 예를 들어, 재사용 가능한 객체 및 리소스의 적절한 관리, 적절한 데이터 구조 선택, 메모리 할당 및 해제 최적화 등이 있다.

iOS에서의 메모리 구조와 관리 방식은 성능과 안정성을 유지하면서 개발자가 메모리 관리에 신경을 덜 수 있도록 설계되었다.
이를 통해 iOS 앱은 효율적으로 동작하고 사용자 경험을 향상시킬 수 있다.

### iOS 앱의 메모리 구조(힙, 스택, 코드 영역 등)와 각 영역의 특징에 대해 설명해주세요.

기본적으로 네 가지 주요 영역으로 구성된다.

1. 코드 영역

- 이 영역은 앱의 실행 가능한 기계 코드를 포함한다.
- 앱이 실행될 때, 메모리에 로드되고 실행 가능한 명령어들이 포함된다.
- 읽기 전용이므로, 앱이 실행 중에 변경될 수 없다.

2. 데이터 영역

- 전역 및 정적 변수들이 할당되는 영역이다.
- 전역 변수, 정적 변수, 문자열 상수 등이 여기에 저장된다.
- 앱의 시작 시점에 할당되며, 프로그램이 종료될 때까지 메모리에 유지된다.

3. 힙 영역

- 동적으로 할당된 메모리를 관리하는 영역이다.
- 런타임 중에 메모리를 동적으로 할당하고 해제할 수 있다.
- 객체 생성 및 해제, 동적 데이터 구조의 할당 및 해제 등이 여기에서 이뤄진다.
- 개발자가 명시적으로 메모리를 할당하고 해제하는 작업을 수행한다. (ARC 또는 수동 해제)

4. 스택 영역

- 지역 변수와 함수 호출에 필요한 정보를 저장하는 영역이다.
- 각 함수 호출은 스택 프레임으로 푸시되고, 함수가 반환될 때 해당 프레임이 팝된다.
- 스택은 후입선출 구조를 가지고, 함수의 실행 흐름에 따라 동적으로 변경된다.

이러한 메모리 구조를 통해 iOS 앱은 메모리를 효율적으로 사용하고, 안정적으로 실행된다.
개발자는 각 영역의 특징을 이해하여 앱을 최적화하고 메모리 관리를 효과적으로 수행할 수 있다.

### 힙 영역에서 객체가 어떻게 할당되고 관리되는지 설명해주세요.

힙 영역은 동적으로 할당된 메모리를 관리하는 영역이다. 주로 객체의 생성 및 해제에 사용된다.

1. 객체 할당

- 객체는 보통 힙 영역에 할당된다. 이는 객체의 크기가 런타임 중에 결정되고, 동적으로 메모리가 할당되어야 하기 때문이다.
- 객체를 생성할 때에는 일반적으로 'alloc' 메서드(또는 'new' 키워드)를 사용해 힙에 메모리를 할당하고 초기화한다.
- Objective-C에서는 다음과 같이 객체를 생성한다.

```objective
    NSObject *myObject = [[NSObject alloc] init];
```

2. 메모리 해제

- 객체를 더 이상 사용하지 않을 때에는 메모리 누수를 방지하기 위해 명시적으로 메모리를 해제해야 한다.
- Objective-C에서는 ARC를 사용해 객체의 참조 카운트를 관리하고, 자동으로 메모리를 해제할 수 있다.
- ARC를 사용하지 않는 경우, 개발자는 'release' 메서드를 사용해 객체의 참조 카운트를 감소시키고, 참조 카운트가 0이 되면 객체를 해제한다.
- Swift에서는 ARC가 기본적으로 사용되며, 개발자가 수동으로 메모리를 관리할 필요가 없다.

3. 메모리 관리

- 객체는 동적으로 할당되고 해제되므로, 메모리 관리가 중요하다.
- 메모리 누수(할당된 메모리가 해제되지 않는 상태)를 방지하기 위해 더 이상 필요하지 않은 객체는 적절히 해제되어야 한다.
- 너무 많은 메모리 할당 및 해제 작업은 성능에 영향을 줄 수 있으므로, 효율적인 메모리 관리가 필요하다.

힙 영역에서 객체는 동적으로 할당되고 해제되는데, 이러한 프로세스는 객체의 라이프사이클에 따라 수행되며, 메모리 누수를 방지하고 앱의 안정성을 유지하기 위해 중요하다.

### 스택 영역에서 함수 호출과 로컬 변수의 메모리 할당 및 해제 과정을 설명해주세요.

1. 함수 호출

- 함수가 호출되면 스택 프레임이 스택에 푸시된다.
- 스택 프레임에는 함수의 매개변수, 지역 변수, 복귀 주소 및 기타 관련 정보가 저장된다.
- 복귀 주소는 함수의 실행이 완료된 후에 반환할 위치를 가리킨다.

2. 로컬 변수의 메모리 할당

- 함수 내에서 선언된 로컬 변수는 스택 프레임에 할당된다.
- 변수의 크기는 컴파일 시간에 결정되며, 해당 크기만큼 스택 프레임이 확장된다.
- 로컬 변수는 해당 함수 내에서만 유효하며, 함수가 실행을 완료하면 해당 변수에 할당된 메모리가 해제된다.

3. 함수 실행

- 함수가 실행되는 동안에는 해당 함수의 스택 프레임이 활성화되어 있다.
- 함수 내에서 선언된 로컬 변수에는 해당 함수 내에서만 접근할 수 있다.

4. 함수 종료 및 메모리 해제

- 함수가 실행을 완료하면, 해당 함수의 스택 프레임이 팝되어 스택에서 제거된다.
- 이 과정에서 함수 내에서 선언된 로컬 변수의 메모리도 함께 해제된다.
- 반환 주소를 사용해 호출자로 돌아가고, 호출자의 스택 프레임이 다시 활성화된다.

이러한 과정을 통해 스택 영역은 함수 호출과 로컬 변수의 메모리 할당 및 해제를 효율적으로 관리하며, 함수의 실행 흐름을 제어한다.
이는 프로그램이 메모리를 효율적으로 사용하고 안정적으로 실행될 수 있도록 도와준다.

---

## 네트워크 프로토콜 스택과 iOS에서의 네트워크 통신 방식에 대해 설명해주세요.

네트워크 프로토콜 스택은 네트워크 통신을 가능하게 하는 다양한 프로토콜의 계층적 구조다.
이 구조는 데이터가 데이터가 한 장치에서 다른 장치로 효율적으로 전송되도록 설계되어있다.
가장 널리 알려진 프로토콜 스택은 TCP/IP 모델과 OSI 모델이다.

**TCP/IP 모델**

이 모델은 인터넷에서 가장 널리 사용되는 프로토콜 스택으로, 네 개의 계층으로 구성된다.

1. 응용 계층

사용자와 직접 상호작용하는 응용 프로그램을 위한 프로토콜을 포함한다.
예를 들어, HTTP, HTTPS, FTP 등이 있다.

2. 전송 계층

네트워크 간 데이터 전송을 관리한다.
주로 TCP와 UDP를 사용한다.

3. 인터넷 계층

데이터 패킷을 송수신하는 기능을 담당한다.
IP가 이 계층의 핵심 프로토콜이다.

4. 링크 계층

물리적 네트워크 하드웨어와의 직접적인 데이터 전송을 담당한다.
이 계층은 Ethernet, Wi-Fi 등의 기술을 포함한다.

**OSI 모델**

이 모델은 네트워크 통신을 이해하기 위한 이론적 모델로, 일곱 개의 계층으로 구성된다.
TCP/IP 모델보다 더 상세한 구분을 제공하지만, 실제 인터넷은 주로 TCP/IP 모델을 기반으로 한다.

**iOS에서의 네트워크 통신 방식**

iOS에서 네트워크 통신을 구현하기 위한 주요 프레임워크와 API는 다음과 같다.

1. URLSession

HTTP와 HTTPS 통신을 위한 가장 일반적인 방법이다.
URLSession을 사용하면 웹 서비스 요청, 데이터 다운로드, 파일 업로드 등의 네트워크 작업을 비동기적으로 수행할 수 있다.

2. CFNetwork

Core Foundation 프레임워크의 일부로, 낮은 수준의 네트워크 통신 기능을 제공한다.
URLSession보다 더 세밀한 제어가 필요한 경우에 사용된다.

3. Socket 통신

TCP/IP 소켓을 직접 관리해야 하는 경우, iOS는 BSD 소켓 API를 제공한다.
또한, 고성능 소켓 통신을 위한 외부 라이브러리인 CocoaAsyncSocket 같은 것들도 많이 사용된다.

4. Bonjour

로컬 네트워크에서 서비스를 발견하고 게시하는 데 사용되는 Zero-configuration networking 기술이다.

5. Network Framework

iOS 12 이상에서 사용할 수 있는 최신 프레임워크로 비동기 네트워킹, 보안 통신, 연결 관리 등을 위한 포괄적인 API 세트를 제공한다.
이 프레임워크는 앱이 네트워크 통신을 보다 쉽게 구현할 수 있도록 설계되어 있다.

iOS 개발자는 이러한 프레임워크와 API를 사용해 다양한 네트워크 요구 사항과 프로토콜을 효과적으로 구현할 수 있다.
특히 URLSession과 Network Framework는 iOS에서 네트워크 통신을 구현하는 데 가장 많이 사용되는 도구다.

### HTTP와 HTTPS의 차이점, iOS에서의 보안 통신 방법에 대해 설명해주세요.

둘 모두 웹에서 데이터를 전송하는 데 사용되는 프로토콜이다.
두 프로토콜의 주요 차이점은 보안 수준에 있다.

**HTTP와 HTTPS 차이점**

1. 보안

가장 기본적인 차이점은 HTTPS가 SSL/TLS 프로토콜을 사용해 데이터를 암호화하는 반면, HTTP는 암호화하지 않는다는 점이다.
이로 인해 HTTPS는 데이터 전송 과정에서 정보가 도청되거나 변조될 위험을 줄여준다.

2. 포트 번호

HTTP는 기본적으로 80번 포트를 사용하고, HTTPS는 443번 포트를 사용한다.

3. 성능

초기 연결 설정에서 HTTPS는 SSL/TLS 핸드셰이크 과정 때문에 HTTP보다 약간 느릴 수 있다.
하지만 최신 웹 브라우저와 서버는 HTTPS 연결 최적화 기술을 통해 이 차이를 최소화한다.

4. URL 시작 부분

HTTPS를 사용하는 웹 페이지는 "https://"로 시작하고, HTTP를 사용하는 웹 페이지는 "http://"로 시작한다.

5. 신뢰성

HTTPS는 웹 사이트의 신뢰성과 사용자의 신뢰를 높이는데 기여한다.
사용자는 브라우저의 보안 아이콘을 통해 사이트가 안전한지 확인할 수 있다.

**iOS에서의 보안 통신 방법**

1. App Transport Security(ATS)

iOS 9 이상에서는 ATS가 기본적으로 활성화되어 있다.
ATS는 애플리케이션이 인터넷을 통해 데이터를 전송할 때, HTTPS를 사용하도록 강제한다.
개발자는 필요에 따라 Info.plist 파일에서 ATS 설정을 조정할 수 있다.

2. SSL/TLS 인증서 검증

iOS 앱이 서버와의 통신을 시작할 때, 클라이언트는 서버의 SSL/TLS 인증서를 검증해 통신의 안정성을 확보할 수 있다.
이 과정은 서버가 신뢰할 수 있는 기관에 의해 인증되었는지 확인한다.

3. Certificate Pinning

이 방법은 앱이 서버의 특정 인증서나 공개 키만 신뢰하도록 설정하는 것이다.
이를 통해 중간자 공격(man-in-the-middle attacks)를 방지할 수 있다.

4. 네트워크 계층 보안(Network Layer Security)

IPsec 같은 네트워크 계층 보안 프로토콜을 사용해 데이터 패킷 자체를 암호화할 수도 있다.

보안 통신을 위한 이러한 방법들은 사용자 데이터의 안전을 보장하고, 데이터 유출이나 변조로부터 보호하는데 필수적이다.
iOS 개발 시에는 항상 최신 보안 권장사항을 따르고, 가능한 한 ATS를 활성화 상태로 유지하는 것이 좋다.

### TCP와 UDP의 차이점에 대해서 설명해 주세요.

TCP와 UDP는 인터넷에서 데이터를 전송하기 위해 사용되는 두 가지 주요 프로토콜이다.
이 두 프로토콜은 전송 계층에 위치하며, 데이터를 보내고 받는 방식에 있어서 서로 다른 특징을 갖고 있다.
각각의 프로토콜은 특정 유형의 네트워크 통신에 적합하도록 설계되었다.

**TCP**

1. 연결 지향적(Connection-Oriented)

TCP는 통신을 시작하기 전에 먼저 연결을 설정하는 과정을 거친다.
이 과정을 통해 데이터가 전송되기 전에 두 시스템 간의 신뢰할 수 있는 연결이 만들어진다.

2. 신뢰성 있는 데이터 전송

TCP는 데이터가 순서대로, 에러 없이 목적지에 도착하도록 보장한다.
패킷 손실이 발생할 경우, 손실된 패킷을 재전송한다.

3. 흐름 제어(Flow Control)

TCP는 네트워크의 혼잡 상태나 수신 측의 데이터 처리 속도를 고려해 데이터의 전송 속도를 조절한다.

4. 혼잡 제어(Congestion Control)

TCP는 네트워크 내의 혼잡을 감지하고, 이를 완화하기 위해 자신의 데이터 전송 속도를 조절한다.

**UDP**

1. 비연결 지향적(Connectionless)

UDP는 데이터 전송을 시작하기 전에 사전에 연결을 설정하지 않는다.
이는 데이터가 빠르게 전송될 수 있도록 하지만, 신뢰성 있는 통신을 보장하지는 않는다.

2. 신뢰성 없는 데이터 전송

UDP는 패킷이 도착하지 않거나 순서가 바꼈을 때, 이를 수정하거나 재전송하지 않는다. 따라서 패킷 손실이 발생할 수 있다.

3. 흐름 제어 및 혼잡 제어 없음

UDP는 흐름 제어나 혼잡 제어 기능이 없어, 네트워크 상태와 무관하게 데이터를 전송한다.

**TCP와 UDP 사용 사례**

1. TCP 사용 사례

웹 페이지 로딩, 이메일 전송, 파일 전송과 같이 데이터의 정확성과 순서가 중요한 애플리케이션에서 주로 사용된다.

2. UDP 사용 사례

실시간 스트리밍, 온라인 게임, VoIP(음성 통화)와 같이 실시간성이 중요하고 일부 패킷 손실을 허용할 수 있는 애플리케이션에서 사용된다.

TCP와 UDP의 이러한 차이점으로 인해, 각기 다른 특성을 요구하는 네트워크 애플리케이션에 적합한 프로토콜을 선택할 수 있다.

### 소켓 통신에 대해 설명해주세요.

소켓 통신은 네트워크 상에서 서로 다른 시스템 간에 데이터를 주고받기 위한 기본적인 방법 중 하나다.
소켓은 네트워크 통신의 끝점을 의미하며, IP 주소와 포트 번호의 조합으로 식별된다.
소켓을 사용해 네트워크 통신을 수행하는 것을 소켓 프로그래밍이라고 한다.
이는 서버와 클라이언트 간의 통신을 가능케 하며 TCP나 UDP 같은 프로토콜을 사용할 수 있다.

**소켓 통신의 구성 요소**

1. 소켓(Socket)

네트워크 통신의 끝점. 소프트웨어 구조로서, 네트워크를 통해 데이터를 송수신하는 기능을 제공한다.

2. IP 주소

네트워크 상의 각 장치를 식별하는 데 사용되는 고유한 주소다.

3. 포트 번호

호스트 내에서 네트워크 서비스를 식별하는 데 사용되는 번호다.
하나의 IP 주소 내에서 여러 네트워크 서비스가 동시에 동작할 수 있도록 한다.

**소켓 프로그래밍의 과정**

1. 소켓 생성

통신을 시작하기 위해 서버와 클라이언트 각각에서 소켓을 생성한다.

2. 바인딩

서버 측에서는 소켓에 IP 주소와 포트 번호를 할당한다. 이를 통해 서버 소켓이 네트워크 상의 특정 주소로 식별될 수 있다.

3. 리스닝

서버 소켓이 클라이언트의 연결 요청을 기다린다.

4. 연결 수락

서버가 클라이언트의 연결 요청을 수락하고, 클라이언트와 데이터를 교환할 준비를 한다.

5. 데이터 송수신

연결이 설정되면 서버와 클라이언트는 데이터를 주고받을 수 있다.
TCP를 사용하는 경우, 연결 지향적인 통신이 이뤄지고, UDP를 사용하는 경우에는 비연결 지향적인 통신이 이뤄진다.

6. 소켓 종료

데이터 전송이 완료되면 양쪽에서 소켓 연결을 종료한다.

**TCP vs UDP 소켓 통신**

1. TCP 소켓 통신

신뢰성 있는 데이터 전송을 제공한다. 데이터가 순서대로 전달되며, 손실된 데이터는 재전송된다.
연결을 시작하기 전에 소켓 간의 연결을 설정하는 과정이 필요하다.

2. UDP 소켓 통신

연결을 설정하지 않고 데이터를 전송한다.
따라서 TCP에 비해 속도가 빠르지만, 데이터의 순서나 전달 여부를 보장하지 않는다.

소켓 통신은 다양한 네트워크 애플리케이션에서 데이터 교환의 기반을 제공한다.
애플리케이션의 요구 사항에 따라 TCP나 UDP 중 적절한 프로토콜을 선택해 사용할 수 있다.

### REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.

REST API는 Representational State Transfer의 약자로, 웹 서비스 간의 상호 작용을 위한 아키텍처 스타일이다.
REST는 자원(Resource)의 상태(정보)를 전송하기 위해 주로 HTTP 프로토콜을 사용한다.
클라이언트 - 서버 간의 통신에서 REST API를 사용하면, 웹 서비스가 제공하는 데이터를 생성, 읽기, 업데이트, 삭제(CRUD)할 수 있는 표준화된 방법을 제공받게 된다.

**REST API의 핵심 개념**

1. 자원(Resource)

URI로 식별되는 데이터의 개체 또는 서비스다.

2. 메소드

자원에 대해 수행할 작업을 정의한다.
주로 HTTP 메서드인 GET, POST, PUT, DELETE가 사용된다.

3. 표현(Representation)

클라이언트와 서버 간에 교환되는 자원의 상태다.
JSON 또는 XML 형식으로 전달된다.

**iOS에서의 네트워크 요청 및 응답 처리**

iOS에서 REST API를 통해 네트워크 요청과 응답을 처리하기 위한 주요 방법에는 `URLSession`을 사용하는 것이 포함된다.
`URLSession`은 iOS에서 HTTP/HTTPS 네트워크 요청을 위한 가장 기본적인 클래스다.

```swift
import Foundation

let url = URL(string: "https://example.com/api/resource")!

let task = URLSession.shared.dataTask(with: url) { data, response, error in
    guard let httpResponse = response as? HTTPURLResponse,
          httpResponse.statusCode == 200,
          let jsonData = data else {
        print("Error: \(error?.localizedDescription ?? "Unknown error")")
        return
    }

    // JSON 데이터 처리
    do {
        let decodedData = try JSONDecoder().decode(MyResource.self, from: jsonData)
        // 성공적으로 받아온 데이터로 무언가를 함
    } catch {
        print("Error decoding JSON: \(error)")
    }
}

task.resume()
```

위 코드는 비동기적으로 실행되며, 서버로부터 응답이 오면 클로저 내의 코드가 실행된다.
클로저 내에서는 HTTP 응답 상태 코드를 확인하고, 올바른 경우 받은 JSON 데이터를 디코딩하여 사용한다.

**고려 사항**

1. 비동기 처리

iOS에서 네트워크 요청은 메인 스레드를 차단하지 않는 비동기 방식으로 처리되어야 한다. 이를 위해 URLSession은 비동기 API를 제공한다.

2. 에러 처리

네트워크 요청 과정에서 다양한 에러가 발생할 수 있으므로 적절한 에러 처리 로직을 구현해야 한다.

3. JSON 직렬화 및 역직렬화

서버와 데이터를 주고받을 때, 주로 JSON 형식을 사용한다.
Swift에서는 `JSONEncoder`와 `JSONDecoder`를 사용해 쉽게 JSON 데이터를 Swift 객체로 변환하거나 그 반대로 처리할 수 있다.

4. 안전한 통신

App Transport Security(ATS)를 활용해 앱의 데이터가 안전하게 전송되도록 해야 한다.
기본적으로 iOS는 앱이 HTTPS를 통해 암호화된 연결만을 사용하도록 요구한다.

REST API를 활용한 앱 개발은 이러한 기술적 요소들을 이해하고 적용하는 것에서 시작된다.
URLSession과 같은 도구를 통해, 앱은 웹 서비스와 효율적으로 통신할 수 있으며, 사용자에게 필요한 정보를 제공하거나 서비스를 이용할 수 있게 된다.

### REST API에서 Method들의 차이점을 설명해주세요.

웹 서버에 요청을 할 때, 어떤 작업을 수행할지 서버에 알려주는 역할을 한다.
각 메소드는 특정한 타입의 작업과 연관되어 있고, 이는 RESTful 서비스의 핵심 원칙 중 하나다.
주로 사용되는 HTTP 메서드에는 GET, POST, PUT, DELETE, PATCH 등이 있다.

**GET**

1. 목적

서버로부터 정보를 조회하는 데 사용된다.

2. 특징

데이터를 변경하지 않는 안전한(수행이 부작용을 일으키지 않는) 요청으로 간주된다.
또한, GET 요청은 멱등성을 가진다. 즉, 같은 요청을 여러 번 수행해도 결과가 동일하다.

3. 사용 예시

사용자 목록을 불러오거나 특정 사용자의 정보를 조회할 때 사용한다.

**POST**

1. 목적

서버에 데이터를 전송해 리소스를 생성하는 데 사용된다.

2. 특징

POST 요청은 데이터를 서버에 제출해 새로운 리소스를 생성하거나, 기존 리소스를 변경할 떄 사용된다.
이 요청은 멱등성이 없다는 특징을 갖고 있다.

3. 사용 예시

새로운 생성자를 생성하거나, 양식 데이터를 제출할 때 사용한다.

**PUT**

1. 목적

서버에 존재하는 리소스를 대체하거나, 존재하지 않는 경우에는 새로운 리소스를 생성하는 데 사용된다.

2. 특징

PUT 요청은 멱등성을 가진다. 같은 요청을 여러 번 수행하더라도 서버 상의 리소스는 처음 요청 이후 변경되지 않는다.

3. 사용 예시

사용자의 프로필 정보를 업데이트하거나, 특정 ID를 가진 데이터를 수정할 때 사용한다.

**PATCH**

1. 목적

서버의 리소스 중 일부를 수정하는 데 사용된다.

2. 특징

PATCH 요청은 리소스의 일부만을 업데이트하고자 할 때 사용된다.
PUT과 달리 전체 리소스를 대체하지 않고, 일부분만 변경한다.
PATCH의 멱등성은 구현 방식에 따라 다를 수 있다.

**DELETE**

1. 목적

서버의 특정 리소스를 삭제하는 데 사용된다.

2. 특징

DELETE 요청 또한 멱등성을 가진다. 같은 요청을 여러 번 수행하더라도 첫 번째 요청 이후, 리소스가 이미 삭제됐기에 상태가 변경되지 않는다.

3. 사용 예시

사용자 계정을 삭제하거나, 특정 데이터를 제거할 때 사용한다.

이러한 HTTP 메서드들은 RESTful API 설계의 핵심 요소다. 각각의 메서드는 서버와의 통신에서 명확한 의도를 갖고 사용된다.
올바른 메서드 선택은 애플리케이션의 명확성, 유지 보수성, 그리고 클라이언트 - 서버 간의 효율적인 통신을 보장하는 데 중요하다.

### HTTP 상태 코드에 대해서 설명해주세요.

HTTP 상태 코드는 웹 서버가 클라이언트(주로 웹 브라우저나 API를 호출하는 애플리케이션)의 요청을 처리한 후, 그 결과를 알려주는 데 사용되는 표준화된 숫자코드다.
이 상태 코드를 통해 클라이언트는 요청이 성공적으로 처리됐는지, 처리 과정에서 어떤 문제가 발생했는지 등을 알 수 있다.
크게 다섯 가지 범주로 나뉜다.

**1XX: 정보 응답(Informational Response)**

1. 100 Continue

클라이언트는 요청을 계속해야 함을 의미한다.

2. 101 Switching Protocols

서버가 클라이언트의 프로토콜 전환 요청을 수락했음을 의미한다.

**2XX: 성공(Success)**

1. 200 OK

요청이 성공적으로 처리됐음을 의미한다.

2. 201 Created

요청이 성공적이며, 새로운 리소스가 생성됐음을 의미한다.

3. 204 No Content

요청은 성공적이지만, 클라이언트에 전송할 콘텐츠가 없음을 의미한다.

**3XX: 리다이렉션(Redirection)**

1. 301 Moved Permanetly

요청한 리소스의 URL이 영구적으로 변경됐음을 의미한다.

2. 302 Found

요청한 리소스가 일시적으로 다른 URL로 이동됐음을 의미한다.

3. 304 Not Modified

조건부 GET 요청이 수행됐으나, 리소스가 변경되지 않았음을 의미한다.

**4XX: 클라이언트 에러(Client Error)**

1. 400 Bad Request

서버가 요청을 이해할 수 없음을 의미한다.

2. 401 Unautorized

요청이 인증을 필요로 함을 의미한다.

3. 403 Forbidden

서버가 요청을 이해했으나, 권한 부족으로 거부됨을 의미한다.

4. 404 Not Found

요청한 리소스를 찾을 수 없음을 의미한다.

5. 405 Method Not Allowed

요청한 메서드가 서버에서 지원되지 않음을 의미한다.

**5XX: 서버 에러(Server Error)**

1. 500 Internal Server Error

서버 내부 오류가 발생해 요청을 처리할 수 없음을 의미한다.

2. 501 Not Implemented

서버가 요청 메서드를 지원하지 않거나, 처리할 수 없음을 의미한다.

3. 503 Service Unavailable

서버가 오버로드됐거나, 유지 보수로 인해 일시적으로 요청을 처리할 수 없음을 의미한다.

---

## iOS에서 메모리 사이즈와 관련된 개념과 고려 사항에 대해 설명해주세요.

iOS 애플리케이션 개발에서 메모리 관리는 매우 중요하다.
iOS 기기는 제한된 양의 물리적 메모리를 갖고 있으며, 애플리케이션이 너무 많은 메모리를 사용하게 되면 시스템 성능에 부정적인 영향을 줄 수 있다.
심한 경우, iOS 시스템은 메모리 사용량이 너무 높은 앱을 강제로 종료시킬 수도 있다.
따라서, 효과적인 메모리 관리는 앱의 성능과 안정성을 유지하는 데 필수적이다.

**iOS 메모리 사이즈와 관련된 주요 개념**

- 물리적 메모리

iOS 기기에 실제로 탑재된 RAM의 양이다. 이 메모리는 운영체제, 애플리케이션, 백그라운드 프로세스 등 시스템 전반에 걸쳐 공유된다.

- 가상 메모리

물리적 메모리보다 큰 메모리 영역을 애플리케이션에 제공하기 위해 사용된다. 가상 메모리 시스템은 필요에 따라 디스크의 스왑 공간을 사용해 RAM을 확장한다.

- 메모리 누수

할당된 메모리가 더 이상 필요하지 않음에도 불구하고 해제되지 않아, 시간이 지남에 따라 사용할 수 있는 메모리 양이 점차 감소하는 현상이다.

- ARC

iOS와 macOS에서 메모리 관리를 자동화하는 컴파일러 기능이다.
객체에 대한 참조 횟수를 추적해 참조 횟수가 0이 되면 해당 객체를 메모리에서 해제한다.

**메모리 관리를 위한 고려 사항**

- 적절한 객체 해제

사용이 완료된 객체는 적절히 해제하여 메모리를 회수해야 한다.
ARC가 대부분의 경우, 자동으로 메모리 관리를 해주지만, 강한 순환 참조와 같은 문제는 개발자가 직접 관리해야 한다.

- 메모리 누수 감지

Xcode의 Instruments 도구를 사용해 애플리케이션의 메모리 사용 패턴을 분석하고 메모리 누수를 감지할 수 있다.
Leaks와 Allocation 도구를 활용해 누수를 찾아내고 해결하는 것이 중요하다.

- 대용량 리소스 관리

이미지, 비디오 파일 등 대용량 리소스의 사용은 메모리 사용량에 큰 영향을 줄 수 있다.
가능한 한 필요한 시점에만 리소스를 메모리에 로드하고, 사용이 완료되면 즉시 해제해야 한다.

- 캐싱 전략

자주 사용되는 데이터나 객체를 캐시에 저장해 두는 것은 성능을 향상시키는 좋은 방법이지만, 너무 많은 데이터를 메모리에 캐싱하면 메모리 부족을 야기할 수 있다.
적절한 캐싱 전략과 메모리 관리 정책이 필요하다.

효과적인 메모리 관리는 애플리케이션의 성능을 최적화하고, 시스템 자원을 효율적으로 사용하며, 사용자 경험을 개선하는 데 중요한 역할을 한다.
따라서 iOS 애플리케이션을 개발할 때는 이러한 메모리 관리 원칙을 고려해 설계하고 구현하는 것이 중요하다.

### iOS 디바이스의 메모리 제약과 앱 메모리 제한에 대해 설명해주세요.

iOS 기기의 메모리 제약은 개발자가 애플리케이션을 설계하고 개발할 때 반드시 고려해야 하는 중요한 요소 중 하나다.
iOS 기기는 제한된 양의 RAM을 갖고 있고, 이는 모든 실행 중인 애플리케이션과 시스템 프로세스가 공유한다.
애플리케이션을 사용할 수 있는 메모리 양은 기기의 물리적 RAM 용량, 현재 시스템의 상태, 그리고 다른 애플리케이션의 메모리 사용량에 따라 달라진다.

**iOS 디바이스의 메모리 제약**

- 물리적 RAM 제한

iOS 기기는 다양한 모델에 따라 RAM 용량이 다르다. 예를 들어, 초기 모델의 아이폰과 아이패드는 현재 모델보다 훨씬 적은 RAM을 탑재하고 있다.
따라서 모든 사용자에게 일관된 경험을 제공하기 위해서는 다양한 메모리 용량을 가진 기기에서 애플리케이션의 성능을 최적화해야 한다.

- 멀티태스킹과 백그라운드 프로세스

iOS는 멀티태스킹을 지원하기에 여러 애플리케이션이 동시에 실행될 수 있다.
백그라운드에서 실행되는 애플리케이션과 시스템 프로세스 역시 메모리를 사용한다.
이는 포어그라운드에서 실행 중인 애플리케이션에 할당될 수 있는 메모리 양을 제한한다.

**앱 메모리 제한**

iOS에서는 각 애플리케이션이 사용할 수 있는 메모리 양에 대한 명시적인 제한을 설정하지 않았다.
대신 시스템은 전체 메모리 사용량을 모니터링하고, 메모리 부족 상황에서 자동으로 메모리를 관리한다.
애플리케이션이 과도하게 많은 메모리를 사용하면, 운영체제는 다음과 같은 단계로 메모리 부족 문제를 해결하려고 시도한다.

1. 메모리 경고 발생

운영체제는 메모리 사용량이 높아질 때, 애플리케이션에 메모리 경고를 발생시킨다.
이는 앱이 메모리를 추가로 할당하기 전에 사용하지 않는 리소스를 해제하도록 권장하는 신호다.

2. 백그라운드 앱 종료

메모리 부족 상황이 지속되면, 시스템은 백그라운드에서 실행 중인 애플리케이션을 강제로 종료해 메모리를 회수한다.

3. 포어그라운드 앱 종료

매우 극단적인 경우, 시스템은 현재 사용자가 사용 중인 애플리케이션마저 강제로 종료할 수 있다.
이는 사용자 경험에 부정적인 영향을 주므로, 개발자는 이런 상황을 가능한 한 피해야 한다.

**메모리 관리 전략**

- 적극적인 메모리 관리

애플리케이션은 메모리 경고에 적극적으로 대응해야 한다. 가능한 경우 캐시된 데이터, 이미지, 그리고 다른 대용량 리소스를 해제하여 메모리 사용량을 줄인다.

- 메모리 사용 최적화

애플리케이션의 메모리 사용을 정기적으로 프로파일링하여 비효율적인 메모리 사용을 최소화한다.
예를 들어, 이미지 크기를 조정하거나 필요할 때만 대용량 객체를 로드하는 등의 최적화를 수행한다.

- 리소스 관리

애플리케이션이 사용하는 리소스의 크기와 수를 신중하게 관리한다.
대용량 리소스는 사용자가 실제로 필요로 할 때만 메모리에 로드한다.

적절한 메모리 관리 전략은 애플리케이션의 성능을 유지하고, 메모리 제약 조건을 효과적으로 관리할 수 있도록 도와준다.

### 메모리 워드(word) 크기와 데이터 정렬(alignment)이 메모리 액세스 성능에 미치는 영향에 대해 설명해주세요.

메모리 워드 크기와 데이터 정렬은 컴퓨터 시스템에서 메모리 접근과 관련된 중요한 개념들이다.
이들은 메모리 액세스 성능에 직접적인 영향을 미친다.

**메모리 워드 크기**

- 정의

메모리 워드는 컴퓨터가 자연스럽게 처리하는 데이터의 표준 크기다.
예를 들어, 32비트 시스템에서는 4바이트가 워드 크기가 되며, 64비트 시스템에서는 8바이트가 워드 크기가 된다.

- 성능 영향

CPU는 한 번의 메모리 액세스로 워드 크기만큼의 데이터를 읽거나 쓸 수 있다.
워드 크기에 맞춰진 데이터는 메모리에서 더 효율적으로 읽히고 쓰인다.
따라서, 워드 크기에 최적화된 데이터 액세스는 메모리 처리 성능을 향상시킨다.

**데이터 정렬**

- 정의

데이터 정렬은 메모리 상에서 변수나 데이터 구조체가 시작하는 주소를 어떻게 배치할지에 대한 규칙이다.
정렬된 데이터는 그 크기의 배수인 주소에서 시작한다.
예를 들어, 4바이트 크기의 정수는 4의 배수인 주소에서 시작되어야 하는 것이다.

- 성능 영향

데이터가 메모리 상에서 적절히 정렬되면, CPU는 더 효율적으로 데이터를 읽고 쓸 수 있다.
비정렬 데이터에 접근할 떄는 추가적인 CPU 사이클이 필요할 수 있으며, 이는 성능 저하를 초래한다.
일부 하드웨어에서는 비정렬 액세스가 지원되지 않거나, 예외를 발생시킬 수도 있다.

**메모리 액세스 성능 최적화**

- 워드 경계에 데이터 배치

가능하면 변수를 워드 크기의 배수인 주소 경계에 배치한다. 이는 메모리 액세스 시, 필요한 CPU 사이클 수를 최소화하는 데 도움이 된다.

- 구조체 패딩

컴파일러는 구조체의 멤버를 적절히 정렬하기 위해 패딩을 추가할 수 있다. 이는 메모리 사용량을 약간 증가시킬 수 있지만, 메모리 액세스 성능을 향상시킨다.

- 캐시 활용 최적화

데이터를 캐시 라인 크기에 맞춰 정렬하면, 캐시 효율성이 향상된다. 캐시 라인을 효율적으로 활용하면 메모리 액세스 성능을 대폭 향상시킬 수 있다.

결론적으로, 메모리 워드 크기와 데이터 정렬은 메모리 액세스 성능에 중요한 영향을 미친다.
이를 최적화하는 것은 고성능 컴퓨팅 시스템 설계와 프로그래밍에서 중요한 고려 사항이다.

### 포인터 크기(32비트, 64비트)에 따른 메모리 사용량 차이와 고려 사항에 대해 설명해주세요.

포인터 크기와 관련된 메모리 사용량의 차이는 주로 32비트와 64비트 시스템 간의 비교에서 명확하게 드러난다.
포인터는 메모리 주소를 저장하는 변수로, 해당 시스템의 주소 지정 가능 범위에 따라 크기가 달라진다.

**메모리 사용량 차이**

- 32비트 시스템

32비트 시스템에서 포인터의 크기는 4바이트다. 이는 시스템이 최대 4GB(2^32 바이트)의 메모리 주소 공간을 직접 관리할 수 있음을 의미한다.

- 64비트 시스템

64비트 시스템에서 포인터의 크기는 8바이트다. 이는 훨씬 더 큰 메모리 주소 공간 최대 16EB(2^64 바이트)를 지원할 수 있음을 의미한다.

**고려 사항**

- 메모리 사용량 증가

64비트 시스템에서는 포인터가 32비트 시스템보다 크기에 동일한 수의 포인터를 저장하기 위해 더 많은 메모리가 필요하다.
이는 특히 포인터를 대량으로 사용하는 애플리케이션에서 메모리 사용량이 증가할 수 있음을 의미한다.

- 성능 개선

더 큰 포인터의 크기와 함께, 64비트 시스템은 일반적으로 더 많은 CPU 레지스터와 더 넓은 데이터 경로를 제공한다.
이는 특정 작업에서 처리량을 개선할 수 있다.

- 호환성 문제

32비트 애플리케이션과 라이브러리는 64비트 시스템에서 실행될 때, 호환성 레이어를 통해 실행될 수 있다.
하지만, 최적의 성능을 위해서는 애플리케이션을 64비트로 재컴파일하는 것이 좋다.

- 주소 지정 가능 메모리 확장

64비트 시스템은 훨씬 더 큰 메모리를 지원하기 때문에 고성능 컴퓨팅, 대규모 데이터베이스, 메모리 집약적 애플리케이션에 이점을 제공한다.

결론적으로 64비트 시스템으로의 전환은 메모리 사용량의 증가와 같은 비용이 발생할 수 있지만,
더 큰 메모리 주소 지정 능력과 개선된 성능, 그리고 미래 지향적인 애플리케이션 설계를 위한 준비라는 이점을 제공한다.
따라서, 시스템과 애플리케이션을 설계하고 개발할 때는 이러한 고려 사항을 충분히 이해하고 반영해야 한다.

### iOS 앱에서 대용량 데이터를 다룰 때 메모리 사이즈를 고려한 최적화 방안에 대해 설명해주세요.

iOS 앱에서 대용량 데이터를 다룰 때는 제한된 메모리 리소스를 효율적으로 관리해야 한다.
메모리 사용을 최적화하지 않으면 앱의 성능 저하, 응답 시간 증가, 심지어 앱이 강제 종료되는 문제가 발생할 수 있다.
다음은 iOS 앱에서 대용량 데이터를 다룰 때 메모리 사이즈를 고려한 최적화 방안이다.

**1. 데이터 스트리밍과 지연 로딩**

- 데이터 스트리밍

필요한 데이터만을 네트워크나 디스크에서 스티리밍하여 메모리에 임시로 저장하고, 사용한 후에는 즉시 해제한다.
이 방법은 특히 멀티미디어 데이터(비디오나 오디오) 처리에 유용하다.

- 지연 로딩(Lazy Loading)

객체의 데이터를 실제로 필요로 하는 순간까지 로딩을 지연시킨다. 이 방법은 메모리 사용량을 줄이고, 앱의 시작 시간을 단축하는 데 도움이 된다.

**2. 데이터 분할**

대용량 데이터를 더 작은 단위로 분할해 필요할 때마다 일부분만 메모리에 로드한다.
사용자 인터페이스에 표시되는 데이터만을 메모리에 유지하고, 나머지는 디스크에 저장한다.

**3. 캐싱 전략**

자주 접근하는 데이터는 메모리 내 캐시에 저장해 빠르게 접근할 수 있도록 한다.
하지만, 캐시 크기가 너무 커지지 않도록 관리해야 한다.
필요가 없어진 캐시는 적극적으로 해제하여 메모리를 회수해야 한다.

**4. 객체 사이즈 축소**

데이터 모델을 최적화하여 객체의 사이즈를 줄인다.
예를 들어, 필요 이상으로 큰 데이터 타입을 사용하지 않도록 주의하고, 불필요한 객체 속성은 제거한다.

**5. Core Data와 같은 데이터 관리 시스템 사용**

Core Data는 iOS에서 제공하는 데이터 모델링 및 관리 프레임워크다.
Core Data는 내부적으로 메모리 관리를 최적화하며, 필요한 데이터만을 메모리에 로드하고 나머지는 디스크에 저장하는 등의 기능을 제공한다.

**6. 압축과 최적화된 데이터 포맷**

데이터를 압축하여 저장하고 전송한다.
또한 JSON이나 XML보다 효율적인 바이너리 데이터 포맷(Protocol Buffers 등)을 사용해 파싱과 메모리 사용을 최적화할 수 있다.

**7. Instruments 도구 사용**

Xcode의 Instruments 도구를 사용해 메모리 사용 패턴을 분석하고, 메모리 누수나 과도한 메모리 사용을 감지한다.
이를 통해 최적화할 부분을 식별하고 개선할 수 있다.

이러한 최적화 방안을 통해, iOS 앱은 제한된 메모리 리소스 내에서도 대용량 데이터를 효과적으로 처리하며, 사용자에게 더 나은 경험을 제공할 수 있다.

---

## 알고리즘의 시간 복잡도와 공간 복잡도의 개념, 빅오 표기법에 대해 설명해주세요.

### 자주 사용되는 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 동작 원리와 시간 복잡도를 설명해주세요.

### 이진 탐색의 원리와 시간 복잡도에 대해 설명해주세요.

### 다이나믹 프로그래밍(Dynamic Programming)의 개념을 설명해주세요.

---

## 자료구조의 종류와 iOS 개발에서 자주 사용되는 자료구조에 대해 설명해주세요.

### 배열, 연결 리스트, 스택, 큐의 특징과 iOS에서의 구현 방법을 설명해주세요.

### 해시 테이블의 개념, 충돌 해결 방법을 설명해주세요.

### 트리 자료구조의 종류(예: 이진 트리, 이진 탐색 트리, AVL 트리)을 설명해주세요.

---

## 동시성 프로그래밍의 개념과 iOS에서의 동시성 처리 방식에 대해 설명해주세요.

### 병렬 처리와 동시 처리의 차이, iOS에서의 멀티코어 활용 방안에 대해 설명해주세요.

---

## 암호화와 보안의 기본 개념, iOS 앱 보안을 위한 방안에 대해 설명해주세요.

### 대칭키 암호화와 비대칭키 암호화의 차이에 대해 설명해주세요.

### 해시 함수의 개념과 활용 사례에 대해 설명해주세요.

---

## 가상 메모리(Virtual Memory)의 개념과 동작 원리에 대해 설명해주세요.

### 가상 메모리의 필요성과 장점에 대해 설명해주세요.

### 페이징(Paging) 기법의 개념과 동작 원리, 페이지 테이블의 역할에 대해 설명해주세요.

### 세그먼테이션(Segmentation) 기법의 개념과 페이징과의 차이점에 대해 설명해주세요.

---

## iOS 앱의 메모리 사용량 최적화를 위한 방안과 고려 사항에 대해 설명해주세요.

### 메모리 캐싱 기법(예: NSCache, 이미지 캐싱)의 개념과 iOS에서의 구현 방법을 설명해주세요.

### 대용량 데이터(예: 이미지, 비디오) 처리 시 메모리 최적화 방안(예: lazy loading, 썸네일 활용)에 대해 설명해주세요.

---

## 데이터베이스의 종류와 iOS에서 주로 사용되는 데이터베이스에 대해 설명해주세요.

### iOS에서 사용되는 SQLite, Core Data, Realm 등의 특징과 사용 사례를 설명해주세요.

### 관계형 데이터베이스의 ACID 특성과 트랜잭션의 개념에 대해 설명해주세요.

### iOS에서 데이터베이스 스키마 버전 관리와 마이그레이션을 처리하는 방법을 설명해주세요.

---

## iOS에서 자동 참조 카운팅(ARC)과 가비지 컬렉션(Garbage Collection)의 차이점에 대해 설명해주세요.

### 가비지 컬렉션의 동작 원리와 장단점에 대해 설명해주세요.

### iOS에서 가비지 컬렉션을 사용하지 않는 이유와 ARC를 선택한 배경에 대해 설명해주세요.

---
